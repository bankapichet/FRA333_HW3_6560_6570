# file สำหรับเขียนคำตอบ
# ในกรณีที่มีการสร้าง function อื่น ๆ ให้ระบุว่า input-output คืออะไรด้วย
'''
ชื่อ_รหัส
1.อภิเชษฐ์_6560
2.ณัฐพงศ์_6570

'''

from HW3_utils import FKHW3
import numpy as np

#==============================================================================================================#
#=============================================<คำตอบข้อ 1>======================================================#
#code here

def endEffectorJacobianHW3(q: list[float]) -> list[float]:
    # เรียกฟังก์ชันคำนวณตำแหน่งและการหมุนของข้อต่อต่าง ๆ
    R, P, R_e, p_e = FKHW3(q)
    
    # สร้างเมทริกซ์ 3x3 ไว้เก็บค่าความเร็วเชิงเส้น (J_v) และความเร็วเชิงมุม (J_w)
    J_v = np.zeros((3, 3))  # ส่วนของความเร็วเชิงเส้น
    J_w = np.zeros((3, 3))  # ส่วนของความเร็วเชิงมุม

    # คำนวณ Jacobian สำหรับข้อต่อทั้ง 3 ข้อ
    for i in range(3):
        # ดึงค่าการหมุนและตำแหน่งของข้อต่อ i
        R_i = R[:, :, i]
        P_i = P[:, i]
        
        # หาแกนหมุนของข้อต่อ i
        z = R_i @ np.array([0, 0, 1])  # แกนหมุนของข้อต่อนั้น
        
        # คำนวณความเร็วเชิงเส้นด้วยการทำ cross product ระหว่างแกนหมุนกับตำแหน่ง end effector
        J_v[:, i] = np.cross(z, (p_e - P_i))  
        
        # ความเร็วเชิงมุมก็คือแกนหมุน z ตรง ๆ
        J_w[:, i] = z

    # รวมความเร็วเชิงเส้นกับความเร็วเชิงมุมในแนวตั้ง กลายเป็น Jacobian Matrix ขนาด 6x3
    J_e = np.vstack((J_v, J_w))
    return J_e


#==============================================================================================================#
#=============================================<คำตอบข้อ 2>======================================================#
#code here

def checkSingularityHW3(q: list[float]) -> bool:
    epsilon = 0.001  # กำหนดค่าวิกฤตเล็ก ๆ เพื่อใช้ตรวจสอบ singularity
    
    # คำนวณ Jacobian Matrix สำหรับ q ที่ส่งเข้ามา
    J_e1 = endEffectorJacobianHW3(q)

    # ตัดเอาส่วนบน 3x3 ของ Jacobian ที่เกี่ยวกับความเร็วเชิงเส้น (J_v)
    J_v1 = J_e1[:3, :3]
    
    # คำนวณค่า determinant ของ J_v1 เพื่อดูว่าเป็น 0 หรือไม่ (บ่งบอก singularity)
    det_J1 = np.linalg.det(J_v1)

    # ถ้า determinant ใกล้ศูนย์มาก ถือว่าอยู่ในสถานะ singular
    if abs(det_J1) < epsilon:
        flag = 1  # อยู่ในสภาวะ Singular
    else:
        flag = 0  # ไม่อยู่ในสภาวะ Singular

    return flag  # คืนค่าผลลัพธ์ว่าหุ่นอยู่ในสถานะ singular หรือไม่ฃ






#==============================================================================================================#
#=============================================<คำตอบข้อ 3>======================================================#
#code here

def computeEffortHW3(q: list[float], w: list[float]) -> list[float]:
    # เรียกใช้ฟังก์ชันเพื่อคำนวณ Jacobian Matrix ของหุ่นยนต์ที่ตำแหน่งข้อต่อ q
    J_e = endEffectorJacobianHW3(q)
    
    # คำนวณ torque หรือความพยายามที่ข้อต่อต้องออกแรง (แรงบิด) โดยใช้ Jacobian Transpose (J_e.T) คูณกับแรง w
    tau = J_e.T @ w  # คำนวณ effort (tau)

    # ส่งค่า torque ที่คำนวณได้กลับไป
    return tau


#==============================================================================================================#